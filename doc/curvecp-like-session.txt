http://codesinchaos.wordpress.com/2012/09/09/curvecp-1/ comments on protocol security
^^ READ IT AGAIN ^^

Client authentication is done using asymmetric crypto, where it keeps the clientâ€™s public key confidential. (TLS on the other hand sends the client certificate in plain, unless you use renegotiation.)

============
Possible reasons for all this hello/cookie mumbo-jumbo?
First packet gives server a short-term client key and indicates willingness to communicate from
a given endpoint. Returned cookie packet gives client short-term server key and indicates valid
server presence at the listening end. Initiate packet uses cookie and short-term server key
to validate client identity by sending the long-term public key in a box.

Hello packet
1. Introduce client short-term key
2. Be bigger than cookie server reply for anti-amplification
3. ??
Cookie packet
1. Embed server's state regarding connection to this client (in the cookie)
2. Introduce server's short-term key

The server doesn't allocate memory to keep track of all the incoming connections, only the Initiate
packets that were successfully unboxed count towards established connections and allocate session
memory.

Initiate packet
1. Return server cookie to indicate legitimate session start
2. Embed client's long-term public key for validation/authentication
3. Optionally some start message data

PROBLEMS
In SSU both parties may be trying to establish connection to each other. This may lead to two
completely separate channels being set up. -- this can be actually a feature.
============



how would all layers (channel, stream, etc) work with cryptobox armors?
secretbox is ok, then we just need to run the curvecp key exchange part to set up secret session key

practical question is how how how quickly test it?
- need to keep ssu streams and channels
- need to modify things to work more efficiently with cryptoboxen



First KeyInitiator message must be bigger from teh connecting client to reduce
amplification attack possibility.
Key initiator exchanges Hello/Cookie/Initiate packets.




Does CurveCP stop replay attacks? Yes. If the attacker makes copies of a legitimate client's
Hello packets then the attacker will receive server Cookie packets without affecting
the server state; these Cookie packets do not leak information and will be rejected
by the legitimate client. If the attacker makes copies of other client packets then
the copies will be rejected by this server and by other servers. If the attacker makes
copies of server packets then the copies will be rejected by this client and by other clients.

CurveCP also provides forward secrecy for the client's long-term public key.
Two minutes after a connection is closed, the server is unable to extract
the client's _long-term public key_ from the network packets that were sent to that server,
and is unable to verify the client's long-term public key from the network packets.
-- that is because client is always using short-term public key to encrypt
-- the only place where client's long-term public key is revealed is in Vouch subpacket

Anti-amplification measures:
The server doesn't retransmit its first packet, the Cookie packet. The client is responsible for repeating its Hello packet to ask for another Cookie packet.

The Initiate from the client must contain proper server Cookie or be discarded.
The more general technique of "remote storage" eliminates storage on a server in favor of storage inside the network: the server sends data as an encrypted authenticated message to itself via the client.

I.e. the cookie from client is actually a blob of information necessary for server to establish connection.




Here's how the forward secrecy works. At the beginning of a connection, the CurveCP server generates a short-term public key S' and short-term secret key s', supplementing its long-term public key S and long-term secret key s. Similarly, the CurveCP client generates its own short-term public key C' and short-term secret key c', supplementing its long-term public key C and long-term secret key c. Almost all components of CurveCP packets are in cryptographic boxes that can be opened only by the short-term secret keys s' and c'. The only exceptions are as follows:

 * Packets from the client contain, unencrypted, the short-term public key C'. This public key is generated randomly for this CurveCP connection; it is tied to the connection but does not leak any other information.
 * The first packet from the client contains a cryptographic box that can be opened by __c' and by s__ (not s'; the client does not know S' at this point). However, this box contains nothing other than constant padding.
 * The first packet from the server contains a cryptographic box that can be opened by __c' and by s__. However, this box contains nothing other than the server's short-term public key S', which is generated randomly for this CurveCP connection, and a cookie, discussed below.
 * The second packet from the client contains a cookie from the server. This cookie is actually a cryptographic box that can be understood only by a "minute key" in the server. Two minutes later the server has discarded this key and is unable to extract any information from the cookie.
 * At the end of the connection, both sides throw away the short-term secret keys s' and c'.





Before a client can create a CurveCP connection, it needs to know
(1) the server's long-term public key and
(2) the server's address.
The server's address has four components:
 * 4 bytes: a global IPv4 address identifying the server gateway. The client sends CurveCP packets through the Internet to this IPv4 address. Typically this address is statically configured into the gateway computer by the gateway administrator, and broadcast through DNS. (In principle, CurveCP can also be used within global address spaces other than IPv4, but this page focuses on IPv4 for concreteness.)
 * 2 bytes: a UDP port. The client sends CurveCP packets to this UDP port. Typically this port is specified by a higher-level protocol using CurveCP, the same way that a TCP port is specified by a higher-level protocol using TCP (e.g., TCP port 25 for mail transfer through SMTP).
 * 16 bytes: an extension understood by the server gateway. The semantics of this extension are decided by the server gateway administrator; the client simply copies the extension without trying to understand it.
 * Variable length, at most 255 bytes: the server's domain name.

The extension structure:
 * Two-level gateway-server structure: The program extracts a local IPv4 or IPv6 or MAC or ... address from the CurveCP extension and forwards the packet accordingly to a local server. That local server is the CurveCP server; it has the corresponding secret key and decrypts the CurveCP packet. This last step of forwarding typically means rewriting the packet header (NAT) to contain the server's local address instead of the gateway's IPv4 address; the opposite translation happens for packets sent out to the Internet.

Client addresses

The client's packets include
(1) the client's short-term public key and
(2) the client's address.
The client's address has three components:
 * 4 bytes: a global IPv4 address identifying the client gateway. The server sends CurveCP packets through the Internet to this IPv4 address. Typically this address is dynamically configured into the client, for example through a DHCP server set up by the client gateway administrator.
 * 2 bytes: a UDP port. The server sends CurveCP packets to this UDP port.
 * 16 bytes: an extension understood by the client gateway. The semantics of this extension are decided by the client gateway administrator; the server simply copies the extension without trying to understand it. Typically this extension is dynamically configured into the client.


