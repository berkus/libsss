/**

@mainpage Library Documentation

@section Introduction

Structured Stream Unleashed, or SSU, is a new transport protocol designed to address the needs
of modern applications that need to juggle many asynchronous communication activities in parallel,
such as downloading different parts of a web page simultaneously and playing multiple audio
and video streams at once.

SSU is based on SST, Structured Streams Transport library designed at MIT.
Please see http://pdos.csail.mit.edu/uia/sst/ for more information on the SST protocol itself.
The SST protocol and libsst prototype implementation were developed as part of the Unmanaged
Internet Architecture (UIA) project at MIT; please see http://pdos.csail.mit.edu/uia/ for
more information. Libssu continues that work by porting the code to a more modern platform.

This documentation is for libssu, a library that implements the SSU protocol in user space.
(Kernel-level implementations of SSU are certainly possible but do not exist yet.)

This library implementation of SSU is written in C++14 and makes heavy use of standard C++11
and C++14 features, as well as boost framework (namely boost.asio, boost.endian, boost.posix_time)
for convenience and portability across platforms.

Here is a quick summary of how to use libssu for communication in your application:

-#  First create an instance of the ssu::host class to hold per-host state.
    You can run multiple virtualized copies of SSU in one process for simulation
    or other purposes by creating several host objects.
-#  Set up a server to accept incoming connections, by creating an instance of ssu::server
    and calling its ssu::server::listen() method.
    In place of the 16-bit port numbers used by TCP and UDP, you will need to provide
    a service name and protocol name for dispatching incoming clients to different servers.
-#  To initiate an outgoing connection from a client to the server, create an ssu::stream object
    and call ssu::stream::connect_to(). To establish a secure connection using strong cryptographic
    authentication and encryption, you'll need the target host's cryptographic EID, which
    can be obtained by calling ssu::identity_host_state::host_identity() on that host's ssu::host
    object. On the client, call ssu::stream::connect_to() with this cryptographic EID, the desired
    service and protocol names, and a second EID generated by ssu::identity::from_ip_address()
    as a "location hint" SSU can use to find the target host.
    The location hint is unnecessary if you use SSU's UIA routing protocol.

*/
