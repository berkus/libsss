/**

@mainpage Library Documentation

@section Introduction

Structured Secure Streams, or SSS, is a new transport protocol designed to address the needs
of modern applications that need to juggle many asynchronous communication activities in parallel,
such as downloading different parts of a web page simultaneously and playing multiple audio
and video streams at once.

SSS is based on SST, Structured Streams Transport library designed at MIT.
Please see http://pdos.csail.mit.edu/uia/sst/ for more information on the SST protocol itself.
The SST protocol and libsst prototype implementation were developed as part of the Unmanaged
Internet Architecture (UIA) project at MIT; please see http://pdos.csail.mit.edu/uia/ for
more information. libsss continues that work by porting the code to a more modern platform.

This documentation is for libsss, a library that implements the SSS protocol in user space.
(Kernel-level implementations of SSS are certainly possible but do not exist yet.)

This library implementation of SSS is written in C++14 and makes heavy use of standard C++11
and C++14 features, as well as boost framework (namely boost.asio, boost.endian, boost.posix_time,
boost.fusion) for convenience and portability across platforms.

Here is a quick summary of how to use libsss for communication in your application:

-#  First create an instance of the sss::host class to hold per-host state.
    You can run multiple virtualized copies of SSS in one process for simulation
    or other purposes by creating several host objects.
-#  Set up a server to accept incoming connections, by creating an instance of sss::server
    and calling its sss::server::listen() method.
    In place of the 16-bit port numbers used by TCP and UDP, you will need to provide
    a service name and protocol name for dispatching incoming clients to different servers.
-#  To initiate an outgoing connection from a client to the server, create an sss::stream object
    and call sss::stream::connect_to(). To establish a secure connection using strong cryptographic
    authentication and encryption, you'll need the target host's cryptographic EID, which
    can be obtained by calling sss::identity_host_state::host_identity() on that host's sss::host
    object. On the client, call sss::stream::connect_to() with this cryptographic EID, the desired
    service and protocol names, and a second EID generated by sss::identity::from_ip_address()
    as a "location hint" SSS could use to find the target host.
    The location hint is unnecessary if you use SSS's UIA routing protocol.

*/
